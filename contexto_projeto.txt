==================== INICIO ARQUIVO: backend/api/models.py ====================
# api/models.py

from django.db import models
from django.contrib.auth.models import User

# Modelo para os Operadores do Sistema (Servidores)
class Servidor(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    nome_completo = models.CharField(max_length=255)

    def __str__(self):
        return self.nome_completo

# Modelo para os Alunos
class Aluno(models.Model):
    # Op√ß√µes para o campo 'turma'
    TURMAS_CHOICES = [
        ('1E', '1¬∫ Ano Eletro'),
        ('2E', '2¬∫ Ano Eletro'),
        ('3E', '3¬∫ Ano Eletro'),
        ('1I', '1¬∫ Ano Info'),
        ('2I', '2¬∫ Ano Info'),
        ('3I', '3¬∫ Ano Info'),
    ]

    nome_completo = models.CharField(max_length=255)
    matricula = models.CharField(max_length=50, unique=True, null=True, blank=True) # Alterado
    turma = models.CharField(max_length=2, choices=TURMAS_CHOICES)

    def __str__(self):
        return self.nome_completo

# Modelo que armazena cada digital e a quem ela pertence
class Digital(models.Model):
    sensor_id = models.IntegerField(primary_key=True)
    aluno = models.ForeignKey(Aluno, on_delete=models.CASCADE, null=True, blank=True, related_name='digitais')
    servidor = models.ForeignKey(Servidor, on_delete=models.CASCADE, null=True, blank=True, related_name='digitais')

    def __str__(self):
        if self.aluno:
            return f"Digital ID {self.sensor_id} - Aluno: {self.aluno.nome_completo}"
        elif self.servidor:
            return f"Digital ID {self.sensor_id} - Servidor: {self.servidor.nome_completo}"
        return f"Digital ID {self.sensor_id} - N√£o associada"

# Modelo para registrar cada retirada de lanche
class RegistroRetirada(models.Model):
    aluno = models.ForeignKey(Aluno, on_delete=models.CASCADE)
    data_retirada = models.DateTimeField(auto_now_add=True) # Salva a data e hora automaticamente

    def __str__(self):
        return f"Retirada de {self.aluno.nome_completo} em {self.data_retirada.strftime('%d/%m/%Y %H:%M')}"
==================== FIM ARQUIVO: backend/api/models.py ====================

==================== INICIO ARQUIVO: backend/api/views.py ====================
# api/views.py (VERS√ÉO FINAL COM EXCLUS√ÉO COMPLETA)

import openpyxl
from rest_framework.parsers import MultiPartParser, FormParser
from datetime import datetime, time
from rest_framework import generics, permissions, status
from rest_framework.views import APIView
from rest_framework.response import Response
from .models import Aluno, Servidor, Digital
from .serializers import AlunoSerializer, ServidorSerializer, ServidorRegisterSerializer, RegistroRetiradaSerializer
from rest_framework_simplejwt.tokens import RefreshToken
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from django.utils import timezone
from .models import RegistroRetirada
from .serializers import MyTokenObtainPairSerializer
from rest_framework_simplejwt.views import TokenObtainPairView


# ---- Views para Alunos ----
class AlunoListCreate(generics.ListCreateAPIView):
    queryset = Aluno.objects.all()
    serializer_class = AlunoSerializer
    
    # --- CORRE√á√ÉO PRINCIPAL AQUI ---
    def get_permissions(self):
        """
        Define permiss√µes diferentes para cada tipo de requisi√ß√£o:
        - GET (listar alunos): Permite qualquer usu√°rio autenticado.
        - POST (criar aluno): Permite apenas superusu√°rios.
        """
        if self.request.method == 'POST':
            # Apenas superusu√°rios podem criar alunos (ex: via API, sem ser pela planilha)
            return [permissions.IsAdminUser()]
        
        # Qualquer usu√°rio logado (servidor ou superuser) pode ver a lista de alunos
        return [permissions.IsAuthenticated()]

# üîΩ --- L√ìGICA DE EXCLUS√ÉO ATUALIZADA AQUI --- üîΩ
class AlunoRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
    queryset = Aluno.objects.all()
    serializer_class = AlunoSerializer
    permission_classes = [permissions.IsAuthenticated]

    def destroy(self, request, *args, **kwargs):
        aluno = self.get_object()
        # Pega a lista de IDs das digitais ANTES de deletar o aluno
        digitais_para_deletar = list(aluno.digitais.all())
        if digitais_para_deletar:
            channel_layer = get_channel_layer()
            # Envia o comando de exclus√£o para o hardware para cada digital
            for digital in digitais_para_deletar:
                command = f"DELETAR:{digital.sensor_id}"
                async_to_sync(channel_layer.group_send)(
                    'serial_worker_group',
                    {'type': 'execute.command', 'command': command}
                )
        return super().destroy(request, *args, **kwargs)


class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer

# ---- Views para Servidores ----
class ServidorRegisterView(generics.CreateAPIView):
    serializer_class = ServidorRegisterSerializer
    permission_classes = [permissions.IsAdminUser]

class ServidorList(generics.ListAPIView):
    queryset = Servidor.objects.all()
    serializer_class = ServidorSerializer
    permission_classes = [permissions.IsAdminUser]

# üîΩ --- L√ìGICA DE EXCLUS√ÉO ATUALIZADA AQUI --- üîΩ
class ServidorRetrieveUpdateDestroy(generics.RetrieveUpdateDestroyAPIView):
    queryset = Servidor.objects.all()
    serializer_class = ServidorSerializer
    permission_classes = [permissions.IsAdminUser]

    def destroy(self, request, *args, **kwargs):
        servidor = self.get_object()
        digitais_para_deletar = list(servidor.digitais.all())

        if digitais_para_deletar:
            channel_layer = get_channel_layer()
            for digital in digitais_para_deletar:
                command = f"DELETAR:{digital.sensor_id}"
                async_to_sync(channel_layer.group_send)(
                    'serial_worker_group',
                    {'type': 'execute.command', 'command': command}
                )

        return super().destroy(request, *args, **kwargs)


# ---- VIEWS PARA COMANDOS DO HARDWARE (J√Å CORRIGIDAS ANTERIORMENTE) ----

class AssociateFingerprintView(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        sensor_id = request.data.get('sensor_id')
        aluno_id = request.data.get('aluno_id')
        servidor_id = request.data.get('servidor_id')

        if not sensor_id:
            return Response({"error": "sensor_id √© obrigat√≥rio"}, status=status.HTTP_400_BAD_REQUEST)
        if not aluno_id and not servidor_id:
            return Response({"error": "aluno_id ou servidor_id √© obrigat√≥rio"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            digital, created = Digital.objects.update_or_create(
                sensor_id=sensor_id,
                defaults={'aluno_id': aluno_id, 'servidor_id': servidor_id}
            )
            return Response({"message": "Digital associada com sucesso"}, status=status.HTTP_200_OK)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class FingerprintLoginView(APIView):
    authentication_classes = []
    permission_classes = [permissions.AllowAny]

    def post(self, request, *args, **kwargs):
        sensor_id = request.data.get('sensor_id')
        if not sensor_id:
            return Response({"error": "sensor_id √© obrigat√≥rio"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            digital = Digital.objects.select_related('servidor__user').get(sensor_id=sensor_id)
            if digital.servidor and digital.servidor.user:
                user = digital.servidor.user
                
                # --- MUDAN√áA CR√çTICA: Usando o serializer customizado ---
                # Em vez de criar um token simples, usamos nosso serializer para
                # criar um token completo com 'username' e 'is_superuser'.
                serializer = MyTokenObtainPairSerializer(context={'request': request})
                refresh = serializer.get_token(user)

                return Response({
                    'refresh': str(refresh),
                    'access': str(refresh.access_token),
                })
            else:
                return Response({"error": "Digital n√£o associada a um operador"}, status=status.HTTP_404_NOT_FOUND)
        except Digital.DoesNotExist:
            return Response({"error": "Digital n√£o encontrada"}, status=status.HTTP_404_NOT_FOUND)



# --- NOVA FUNCIONALIDADE: VIEWS PARA INICIAR A√á√ïES CR√çTICAS ---

class InitiateDeleteByTurmaView(APIView):
    """
    Inicia o processo de exclus√£o em massa de alunos de uma turma espec√≠fica.
    N√£o executa a exclus√£o, apenas "arma" o worker para aguardar a confirma√ß√£o biom√©trica.
    """
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, *args, **kwargs):
        turma = request.data.get('turma')
        if not turma:
            return Response({"error": "O campo 'turma' √© obrigat√≥rio."}, status=status.HTTP_400_BAD_REQUEST)

        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            'serial_worker_group',
            {
                'type': 'arm.action',
                'action': {
                    'type': 'delete_by_turma',
                    'turma': turma
                }
            }
        )
        return Response({"message": f"A√ß√£o de exclus√£o para a turma '{turma}' iniciada. Aguardando confirma√ß√£o biom√©trica no leitor."}, status=status.HTTP_202_ACCEPTED)

class InitiateClearAllView(APIView):
    """
    Inicia o processo de limpeza total do leitor com confirma√ß√£o biom√©trica.
    """
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, *args, **kwargs):
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            'serial_worker_group',
            {
                'type': 'arm.action',
                'action': {
                    'type': 'clear_all_fingerprints'
                }
            }
        )
        return Response({"message": "A√ß√£o de limpeza total iniciada. Aguardando confirma√ß√£o biom√©trica no leitor."}, status=status.HTTP_202_ACCEPTED)

class InitiateDeleteStudentFingerprintsView(APIView):
    """ Inicia a exclus√£o segura das digitais de um aluno espec√≠fico. """
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        aluno_id = kwargs.get('aluno_id')
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            'serial_worker_group',
            {
                'type': 'arm.action',
                'action': {
                    'type': 'delete_student_fingerprints',
                    'aluno_id': aluno_id
                }
            }
        )
        return Response({"message": "A√ß√£o de exclus√£o de digitais iniciada. Aguardando confirma√ß√£o biom√©trica."}, status=status.HTTP_202_ACCEPTED)

class InitiateDeleteServerFingerprintsView(APIView):
    """ Inicia a exclus√£o segura das digitais de um servidor espec√≠fico. """
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, *args, **kwargs):
        servidor_id = kwargs.get('servidor_id')
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            'serial_worker_group',
            {
                'type': 'arm.action',
                'action': {
                    'type': 'delete_server_fingerprints',
                    'servidor_id': servidor_id
                }
            }
        )
        return Response({"message": "A√ß√£o de exclus√£o de digitais iniciada. Aguardando confirma√ß√£o biom√©trica."}, status=status.HTTP_202_ACCEPTED)
    

class AlunoUploadPlanilhaView(APIView):
    permission_classes = [permissions.IsAdminUser]
    parser_classes = (MultiPartParser, FormParser)

    def post(self, request, *args, **kwargs):
        planilha_file = request.FILES.get('planilha')
        if not planilha_file:
            return Response({"error": "Nenhuma planilha enviada."}, status=status.HTTP_400_BAD_REQUEST)

        try:
            workbook = openpyxl.load_workbook(planilha_file)

            # --- MUDAN√áA PRINCIPAL: Inicializa os contadores fora do loop ---
            alunos_criados = 0
            alunos_existentes = 0
            alunos_turma_invalida = 0
            erros_reais = []

            # --- MUDAN√áA PRINCIPAL: Itera sobre TODAS as planilhas (abas) no arquivo ---
            for sheet in workbook.worksheets:
                
                # A l√≥gica de mapeamento e leitura de colunas agora acontece para cada aba
                current_year = datetime.now().year
                ano_1 = current_year % 100
                ano_2 = (current_year - 1) % 100
                ano_3 = (current_year - 2) % 100

                turma_map = {
                    f"MIEL1{ano_1}IA": "1E", f"MIII1{ano_1}IA": "1I",
                    f"MIEL1{ano_2}IA": "2E", f"MIII1{ano_2}IA": "2I",
                    f"MIEL1{ano_3}IA": "3E", f"MIII1{ano_3}IA": "3I",
                }

                headers = [str(cell.value).strip().lower() if cell.value else "" for cell in sheet[1]]
                try:
                    nome_col_index = headers.index("nome")
                    turma_col_index = headers.index("turma")
                except ValueError:
                    # Se uma aba n√£o tiver os cabe√ßalhos corretos, ela √© pulada
                    erros_reais.append(f"Aba '{sheet.title}' ignorada: Cabe√ßalhos 'Nome' e/ou 'Turma' n√£o encontrados.")
                    continue

                # Itera sobre as linhas da aba atual
                for row_index, row in enumerate(sheet.iter_rows(min_row=2, values_only=True), start=2):
                    try:
                        nome_completo = row[nome_col_index]
                        codinome_turma = row[turma_col_index]

                        if not nome_completo or not codinome_turma:
                            continue
                        
                        codinome_turma_str = str(codinome_turma).strip()
                        turma = turma_map.get(codinome_turma_str)

                        if not turma:
                            alunos_turma_invalida += 1
                            continue

                        if Aluno.objects.filter(nome_completo__iexact=nome_completo, turma=turma).exists():
                            alunos_existentes += 1
                            continue
                        
                        Aluno.objects.create(nome_completo=nome_completo, turma=turma)
                        alunos_criados += 1
                    
                    except Exception as e:
                        erros_reais.append(f"Aba '{sheet.title}', Linha {row_index}: Erro inesperado - {str(e)}")

            # O relat√≥rio final agora √© um resumo de todas as abas processadas
            return Response({
                "message": "Processamento da planilha conclu√≠do.",
                "criados": alunos_criados,
                "existentes_ignorados": alunos_existentes,
                "turmas_invalidas_ignoradas": alunos_turma_invalida,
                "erros": erros_reais
            }, status=status.HTTP_200_OK)

        except Exception as e:
            return Response({"error": f"Erro grave ao abrir ou processar a planilha: {str(e)}"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        

class RegistrosDeHojeView(generics.ListAPIView):
    serializer_class = RegistroRetiradaSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        # Esta view agora usa o 'time' correto de 'datetime'
        hoje = timezone.localtime(timezone.now()).date()
        agora_time = timezone.localtime(timezone.now()).time()
        if agora_time.hour < 12:
            periodo_inicio = timezone.make_aware(datetime.combine(hoje, time.min))
        else:
            periodo_inicio = timezone.make_aware(datetime.combine(hoje, time(12, 0)))
        return RegistroRetirada.objects.filter(data_retirada__gte=periodo_inicio).order_by('-data_retirada')[:5]
    

class InitiateDeleteStudentView(APIView):
    """ Inicia a exclus√£o segura de um aluno completo (registro e digitais). """
    permission_classes = [permissions.IsAuthenticated]

    def post(self, request, *args, **kwargs):
        aluno_id = kwargs.get('aluno_id')
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            'serial_worker_group',
            {
                'type': 'arm.action',
                'action': {
                    'type': 'delete_student', # Novo tipo de a√ß√£o
                    'aluno_id': aluno_id
                }
            }
        )
        return Response({"message": "A√ß√£o de exclus√£o de aluno iniciada. Aguardando confirma√ß√£o biom√©trica."}, status=status.HTTP_202_ACCEPTED)
    

class InitiateDeleteServerView(APIView):
    """ Inicia a exclus√£o segura de um servidor completo (registro e digitais). """
    permission_classes = [permissions.IsAdminUser]

    def post(self, request, *args, **kwargs):
        servidor_id = kwargs.get('servidor_id')
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            'serial_worker_group',
            {
                'type': 'arm.action',
                'action': {
                    'type': 'delete_server', # Novo tipo de a√ß√£o
                    'servidor_id': servidor_id
                }
            }
        )
        return Response({"message": "A√ß√£o de exclus√£o de servidor iniciada. Aguardando confirma√ß√£o biom√©trica."}, status=status.HTTP_202_ACCEPTED)
==================== FIM ARQUIVO: backend/api/views.py ====================

==================== INICIO ARQUIVO: backend/api/serializers.py ====================
# api/serializers.py (VERS√ÉO CORRIGIDA E ROBUSTA)

from rest_framework import serializers
from django.contrib.auth.models import User
from django.db import transaction
from .models import Aluno, Servidor, Digital, RegistroRetirada
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework_simplejwt.views import TokenObtainPairView

# --- SERIALIZERS EXISTENTES (SEM MUDAN√áAS) ---

class DigitalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Digital
        fields = ['sensor_id']

class AlunoSerializer(serializers.ModelSerializer):
    digitais_count = serializers.SerializerMethodField()

    class Meta:
        model = Aluno
        fields = ['id', 'nome_completo', 'matricula', 'turma', 'digitais_count']

    def get_digitais_count(self, obj):
        return obj.digitais.count()

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'is_superuser'] # Removido first_name para consist√™ncia, nome_completo vem do Servidor

# Serializer para listar/detalhar Servidores
class ServidorSerializer(serializers.ModelSerializer):
    user = UserSerializer(read_only=True) # user √© apenas para leitura aqui
    digitais_count = serializers.SerializerMethodField()

    class Meta:
        model = Servidor
        fields = ['id', 'nome_completo', 'user', 'digitais_count']

    def get_digitais_count(self, obj):
        return obj.digitais.count()

# --- SERIALIZER DE REGISTRO (VERS√ÉO CORRIGIDA) ---
# Este serializer agora lida com a cria√ß√£o de um Servidor e seu User associado.
class ServidorRegisterSerializer(serializers.ModelSerializer):
    # Campos que vamos receber do frontend. Nenhum deles pertence diretamente ao modelo Servidor,
    # por isso s√£o 'write_only'.
    username = serializers.CharField(write_only=True, required=True)
    password = serializers.CharField(write_only=True, required=True, style={'input_type': 'password'})

    class Meta:
        model = Servidor
        # O 'nome_completo' √© o √∫nico campo que de fato pertence ao modelo Servidor
        fields = ('nome_completo', 'username', 'password')

    def validate_username(self, value):
        """ Valida se o nome de usu√°rio j√° existe para evitar erros de banco de dados. """
        if User.objects.filter(username__iexact=value).exists():
            raise serializers.ValidationError("Este nome de usu√°rio j√° est√° em uso.")
        return value

    @transaction.atomic # Garante que ou tudo √© criado com sucesso, ou nada √© salvo.
    def create(self, validated_data):
        """
        Cria um novo objeto User e depois um objeto Servidor associado a ele.
        """
        # Cria o usu√°rio com o m√©todo seguro que criptografa a senha
        user = User.objects.create_user(
            username=validated_data['username'],
            password=validated_data['password']
        )
        # Define o usu√°rio como staff para que possa acessar o admin do Django, se necess√°rio
        user.is_staff = True
        user.save()

        # Cria o servidor, associando o usu√°rio rec√©m-criado
        servidor = Servidor.objects.create(
            user=user,
            nome_completo=validated_data['nome_completo']
        )
        return servidor
    

class RegistroRetiradaSerializer(serializers.ModelSerializer):
    # Para incluir o nome e a turma do aluno no resultado
    nome_aluno = serializers.CharField(source='aluno.nome_completo', read_only=True)
    turma_aluno = serializers.CharField(source='aluno.turma', read_only=True)

    class Meta:
        model = RegistroRetirada
        fields = ['id', 'nome_aluno', 'turma_aluno', 'data_retirada']


# Adicione esta nova classe no final do arquivo
class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    @classmethod
    def get_token(cls, user):
        token = super().get_token(user)

        # Adiciona informa√ß√µes customizadas ao payload do token
        token['username'] = user.username
        token['is_superuser'] = user.is_superuser

        return token
==================== FIM ARQUIVO: backend/api/serializers.py ====================

==================== INICIO ARQUIVO: backend/api/urls.py ====================
# api/urls.py

from django.urls import path
from . import views

# --- MUDAN√áA: Simplificando os imports, j√° que algumas views ser√£o removidas ---
from .views import (
    AlunoListCreate, AlunoRetrieveUpdateDestroy, AlunoUploadPlanilhaView,
    ServidorList, ServidorRegisterView, ServidorRetrieveUpdateDestroy,
    AssociateFingerprintView, FingerprintLoginView,
    InitiateDeleteByTurmaView, InitiateClearAllView,
    InitiateDeleteStudentFingerprintsView, InitiateDeleteServerFingerprintsView, # Novas views
    RegistrosDeHojeView, InitiateDeleteStudentView, InitiateDeleteServerView 
)

from rest_framework_simplejwt.views import TokenRefreshView
from .views import MyTokenObtainPairView # Importa a nossa view customizada

urlpatterns = [
    # Rotas de Autentica√ß√£o (Login)
    path('token/', views.MyTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    path('token/fingerprint/', FingerprintLoginView.as_view(), name='token_fingerprint'),

    # Rotas para Alunos
    path('alunos/', views.AlunoListCreate.as_view(), name='aluno-list-create'),
    path('alunos/<int:pk>/', views.AlunoRetrieveUpdateDestroy.as_view(), name='aluno-detail'),
    path('alunos/upload-planilha/', views.AlunoUploadPlanilhaView.as_view(), name='aluno-upload-planilha'),

    # Rotas para Servidores
    path('servidores/', views.ServidorList.as_view(), name='servidor-list'),
    path('servidores/register/', views.ServidorRegisterView.as_view(), name='servidor-register'),
    path('servidores/<int:pk>/', views.ServidorRetrieveUpdateDestroy.as_view(), name='servidor-detail'),

    # Rotas para A√ß√µes de Hardware
    path('digitais/associar/', AssociateFingerprintView.as_view(), name='associate-fingerprint'),

    # --- ROTAS SEGURAS PARA INICIAR A√á√ïES CR√çTICAS (COM CONFIRMA√á√ÉO BIOM√âTRICA) ---
    path('actions/initiate-clear-all/', views.InitiateClearAllView.as_view(), name='initiate-clear-all'),
    path('actions/initiate-delete-by-turma/', views.InitiateDeleteByTurmaView.as_view(), name='initiate-delete-by-turma'),
    # --- NOVO: Rotas para iniciar a exclus√£o de digitais de um √∫nico usu√°rio ---
    path('actions/initiate-delete-student-fingerprints/<int:aluno_id>/', views.InitiateDeleteStudentFingerprintsView.as_view(), name='initiate-delete-student-fingerprints'),
    path('actions/initiate-delete-server-fingerprints/<int:servidor_id>/', views.InitiateDeleteServerFingerprintsView.as_view(), name='initiate-delete-server-fingerprints'),
    # --- Rota: confirma√ß√£o de exclus√£o de aluno
    path('actions/initiate-delete-student/<int:aluno_id>/', views.InitiateDeleteStudentView.as_view(), name='initiate-delete-student'),
    # --- Rota: confirma√ß√£o de exclus√£o de servidor
    path('actions/initiate-delete-server/<int:servidor_id>/', views.InitiateDeleteServerView.as_view(), name='initiate-delete-server'),


    path('registros/hoje/', views.RegistrosDeHojeView.as_view(), name='registros-hoje'),
]
==================== FIM ARQUIVO: backend/api/urls.py ====================

==================== INICIO ARQUIVO: backend/api/management/commands/listen_serial.py ====================
# api/management/commands/listen_serial.py (VERS√ÉO FINAL COM L√ìGICA DE CONFIRMA√á√ÉO)
import serial
import serial.tools.list_ports
import asyncio
import time
from django.core.management.base import BaseCommand
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync, sync_to_async
from api.models import Aluno, Digital, RegistroRetirada, Servidor
from django.core.cache import cache 
from api.serializers import AlunoSerializer
from datetime import time as dtime
from django.utils import timezone

TARGET_HWID = "USB VID:PID=1A86:7523" 
BAUD_RATE = 115200
ACTION_TIMEOUT = 30 # Segundos para aguardar a confirma√ß√£o biom√©trica

def find_serial_port_by_hwid():
    """
    Sonda as portas seriais e encontra o dispositivo com o HWID correspondente.
    """
    print("Procurando o dispositivo LancheGO pelo HWID...")
    
    ports = serial.tools.list_ports.comports()
    if not ports:
        print("Nenhuma porta serial encontrada.")
        return None

    for port in ports:
        if TARGET_HWID in port.hwid:
            print(f"Dispositivo LancheGO encontrado na porta {port.device}!")
            return port.device
            
    print(f"Dispositivo com HWID contendo '{TARGET_HWID}' n√£o foi encontrado.")
    return None

def get_aluno_data_sync(aluno):
    return AlunoSerializer(aluno).data

async def process_serial_data(line, channel_layer, command_instance):
    # --- NOVA L√ìGICA DE CONFIRMA√á√ÉO DE A√á√ÉO PENDENTE ---
    if line.startswith('MATCH:') and command_instance.pending_action:
        try:
            sensor_id = int(line.split(':')[1])
            digital = await sync_to_async(Digital.objects.select_related('servidor__user').get)(sensor_id=sensor_id)

            # Verifica se a digital pertence a um superusu√°rio
            if digital.servidor and digital.servidor.user and digital.servidor.user.is_superuser:
                command_instance.stdout.write(command_instance.style.SUCCESS(f"CONFIRMA√á√ÉO ACEITA do superuser: {digital.servidor.user.username}"))
                await command_instance.execute_pending_action()
            else:
                command_instance.stdout.write(command_instance.style.ERROR("Confirma√ß√£o negada. A digital n√£o pertence a um superusu√°rio."))
                await channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'error', 'message': 'Acesso Negado: A digital n√£o √© de um superusu√°rio.'}})
                await command_instance.cancel_pending_action(send_message=False) # Apenas cancela internamente
        except Digital.DoesNotExist:
            command_instance.stdout.write(command_instance.style.ERROR("Confirma√ß√£o negada. Digital n√£o encontrada no sistema."))
            await channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'error', 'message': 'Acesso Negado: Digital n√£o cadastrada.'}})
            await command_instance.cancel_pending_action(send_message=False)
        return # Impede que o resto da fun√ß√£o seja executado


    message_to_send = None
    target_group = 'dashboard_group'

    if line.startswith('MATCH:'):
        try:
            sensor_id = int(line.split(':')[1])
            digital = await sync_to_async(Digital.objects.select_related('aluno', 'servidor__user').get)(sensor_id=sensor_id)
            if digital.servidor:
                target_group = 'login_group'
                message_to_send = {'type': 'operador.login', 'status': 'MATCH', 'sensor_id': sensor_id}
            elif digital.aluno:
                aluno = digital.aluno
                agora_local = timezone.localtime(timezone.now())
                hoje = agora_local.date()
                agora_time = agora_local.time()
                periodo_manha_qs = RegistroRetirada.objects.filter(aluno=aluno, data_retirada__date=hoje, data_retirada__time__lt=dtime(12, 0))
                periodo_tarde_qs = RegistroRetirada.objects.filter(aluno=aluno, data_retirada__date=hoje, data_retirada__time__gte=dtime(12, 0))
                ja_retirou_hoje = await sync_to_async(periodo_manha_qs.exists)() if agora_time < dtime(12, 0) else await sync_to_async(periodo_tarde_qs.exists)()
                aluno_data = await sync_to_async(get_aluno_data_sync)(aluno)
                if ja_retirou_hoje: message_to_send = {'type': 'identificacao.result', 'status': 'J√Å RETIROU', 'aluno': aluno_data}
                else:
                    await sync_to_async(RegistroRetirada.objects.create)(aluno=aluno)
                    message_to_send = {'type': 'identificacao.result', 'status': 'LIBERADO', 'aluno': aluno_data}
            else: message_to_send = {'type': 'identificacao.result', 'status': 'NAO_ENCONTRADO', 'aluno': None}
        except Digital.DoesNotExist: message_to_send = {'type': 'identificacao.result', 'status': 'NAO_ENCONTRADO', 'aluno': None}
    elif line == 'NAO_ENCONTRADO': message_to_send = {'type': 'identificacao.result', 'status': 'NAO_ENCONTRADO', 'aluno': None}
    elif line.startswith(('INFO:', 'CADASTRO_OK:', 'CADASTRO_ERRO:')):
        if line.startswith('INFO:'): message_to_send = {'type': 'cadastro.feedback', 'message': line.split(':', 1)[1].strip()}
        elif line.startswith('CADASTRO_OK:'): message_to_send = {'type': 'cadastro.success', 'sensor_id': int(line.split(':')[1])}
        elif line.startswith('CADASTRO_ERRO:'): message_to_send = {'type': 'cadastro.error', 'message': line.split(':', 1)[1].strip()}
    elif line.startswith('DELETAR_OK:') or line.startswith('DELETAR_ERRO:'):
        parts = line.split(':'); status = 'OK' if parts[0] == 'DELETAR_OK' else 'ERROR'; sensor_id = int(parts[1])
        if status == 'OK':
            await sync_to_async(Digital.objects.filter(sensor_id=sensor_id).delete)()
            command_instance.stdout.write(f"-> Digital {sensor_id} deletada do banco (Hardware confirmou).")
        message_to_send = {'type': 'delete.result', 'status': status, 'sensor_id': sensor_id}
    elif line == 'LIMPAR_OK' or line == 'LIMPAR_ERRO':
        status = 'OK' if line == 'LIMPAR_OK' else 'ERROR'
        if status == 'OK':
            await sync_to_async(Digital.objects.all().delete)()
            command_instance.stdout.write(f"-> TODAS as digitais deletadas do banco (Hardware confirmou).")
        message_to_send = {'type': 'clearall.result', 'status': status}

    if message_to_send:
        await channel_layer.group_send(target_group, {'type': 'broadcast_message', 'message': message_to_send})
        command_instance.stdout.write(f"-> Mensagem enviada para '{target_group}'")

class Command(BaseCommand):
    help = 'Starts a unified worker to listen to serial port and receive commands via Channels.'
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.pending_action = None
        self.action_timer = None
        self.ser = None # Para acessar o `ser` em outras fun√ß√µes
        self.channel_layer = get_channel_layer()

    async def cancel_pending_action(self, send_message=True):
        if self.pending_action:
            self.stdout.write(self.style.WARNING("A√ß√£o pendente cancelada por timeout ou nova a√ß√£o."))
            if send_message:
                await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'info', 'message': 'A√ß√£o cancelada: tempo esgotado.'}})
            self.pending_action = None
        if self.action_timer:
            self.action_timer.cancel()
            self.action_timer = None

    async def execute_pending_action(self):
        if not self.pending_action: return
        action = self.pending_action
        action_type = action.get('type')
        
        # --- MUDAN√áA: Adicionando as novas a√ß√µes de exclus√£o individual ---
        if action_type == 'delete_by_turma': await self._execute_delete_by_turma(action)
        elif action_type == 'clear_all_fingerprints': await self._execute_clear_all()
        elif action_type == 'delete_student_fingerprints': await self._execute_delete_user_fingerprints(action, 'aluno')
        elif action_type == 'delete_server_fingerprints': await self._execute_delete_user_fingerprints(action, 'servidor')
        elif action_type == 'delete_student': await self._execute_delete_student(action)
        elif action_type == 'delete_server': await self._execute_delete_server(action)

        
        await self.cancel_pending_action(send_message=False) # Limpa a a√ß√£o ap√≥s execu√ß√£o

    @sync_to_async
    def _get_students_by_turma(self, turma):
        return list(Aluno.objects.filter(turma=turma).prefetch_related('digitais'))

    async def _execute_delete_by_turma(self, action):
        turma = action.get('turma')
        self.stdout.write(self.style.SUCCESS(f"EXECUTANDO exclus√£o em massa para a turma: {turma}"))
        students_to_delete = await self._get_students_by_turma(turma)
        
        if not students_to_delete:
            await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'info', 'message': f"Nenhum aluno encontrado para a turma '{turma}'."}})
            return

        for student in students_to_delete:
            for digital in student.digitais.all():
                command = f"DELETAR:{digital.sensor_id}\n"
                self.ser.write(command.encode('utf-8'))
                self.stdout.write(f"-> Comando enviado: DELETAR:{digital.sensor_id} (Aluno: {student.nome_completo})")
                await asyncio.sleep(0.1) # Pequena pausa para n√£o sobrecarregar o sensor
        
        # Apaga os alunos do banco de dados (o cascade remover√° as digitais)
        await sync_to_async(Aluno.objects.filter(turma=turma).delete)()
        
        message = f"{len(students_to_delete)} aluno(s) da turma '{turma}' e suas digitais foram removidos com sucesso."
        await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'success', 'message': message}})

    async def _execute_delete_server(self, action):
        servidor_id = action.get('servidor_id')

        user, digitais_to_delete = await self._get_user_and_digitais(servidor_id, 'servidor')

        if not user:
            message = "Servidor n√£o encontrado para exclus√£o."
            self.stdout.write(self.style.WARNING(message))
            await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'error', 'message': message}})
            return

        # --- PROTE√á√ÉO ADICIONAL ---
        # Impede que um superusu√°rio apague a si mesmo ou outro superusu√°rio se n√£o for a inten√ß√£o
        if user.user.is_superuser:
            self.stdout.write(self.style.ERROR(f"Tentativa de exclus√£o do superusu√°rio '{user.nome_completo}' bloqueada pela l√≥gica de execu√ß√£o."))
            message = f"Exclus√£o de Superusu√°rio '{user.nome_completo}' n√£o √© permitida por este m√©todo."
            await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'error', 'message': message}})
            return

        self.stdout.write(self.style.SUCCESS(f"EXECUTANDO exclus√£o completa do servidor: {user.nome_completo}"))

        if digitais_to_delete:
            for digital in digitais_to_delete:
                command = f"DELETAR:{digital.sensor_id}\n"
                self.ser.write(command.encode('utf-8'))
                self.stdout.write(f"-> Comando enviado: DELETAR:{digital.sensor_id}")
                await asyncio.sleep(0.1)

        # Apaga o usu√°rio do banco (o cascade do Django cuidar√° de apagar o servidor e as refs das digitais)
        await sync_to_async(user.user.delete)()

        message = f"Servidor '{user.nome_completo}' e suas digitais foram removidos com sucesso."
        await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'success', 'message': message}})


    async def _execute_delete_student(self, action):
        aluno_id = action.get('aluno_id')

        user, digitais_to_delete = await self._get_user_and_digitais(aluno_id, 'aluno')

        if not user:
            message = "Aluno n√£o encontrado para exclus√£o."
            self.stdout.write(self.style.WARNING(message))
            await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'error', 'message': message}})
            return

        self.stdout.write(self.style.SUCCESS(f"EXECUTANDO exclus√£o completa do aluno: {user.nome_completo}"))

        # 1. Envia comandos para apagar as digitais do hardware
        if digitais_to_delete:
            for digital in digitais_to_delete:
                command = f"DELETAR:{digital.sensor_id}\n"
                self.ser.write(command.encode('utf-8'))
                self.stdout.write(f"-> Comando enviado: DELETAR:{digital.sensor_id}")
                await asyncio.sleep(0.1)

        # 2. Apaga o aluno do banco de dados (o cascade do Django cuidar√° de apagar as refs das digitais)
        await sync_to_async(user.delete)()

        message = f"Aluno '{user.nome_completo}' e suas digitais foram removidos com sucesso."
        await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'success', 'message': message}})

    async def _execute_clear_all(self):
        self.stdout.write(self.style.SUCCESS("EXECUTANDO limpeza total do leitor..."))
        command = "LIMPAR\n"
        self.ser.write(command.encode('utf-8'))
        # A confirma√ß√£o e exclus√£o do banco vir√£o do `process_serial_data` ao receber `LIMPAR_OK`
        # Mas enviamos um feedback imediato de sucesso para o frontend
        await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'success', 'message': 'Comando para limpar leitor enviado. O sistema ser√° atualizado ap√≥s a confirma√ß√£o do hardware.'}})


    # --- NOVO: M√©todo gen√©rico para apagar digitais de um usu√°rio espec√≠fico ---
    @sync_to_async
    def _get_user_and_digitais(self, user_id, user_type):
        model = Aluno if user_type == 'aluno' else Servidor
        try:
            user = model.objects.prefetch_related('digitais').get(pk=user_id)
            return user, list(user.digitais.all())
        except model.DoesNotExist:
            return None, []

    async def _execute_delete_user_fingerprints(self, action, user_type):
        user_id_key = 'aluno_id' if user_type == 'aluno' else 'servidor_id'
        user_id = action.get(user_id_key)
        
        user, digitais_to_delete = await self._get_user_and_digitais(user_id, user_type)

        if not user or not digitais_to_delete:
            message = f"{user_type.capitalize()} n√£o encontrado ou n√£o possui digitais."
            self.stdout.write(self.style.WARNING(message))
            await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'info', 'message': message}})
            return

        self.stdout.write(self.style.SUCCESS(f"EXECUTANDO exclus√£o de digitais para {user_type}: {user.nome_completo}"))
        
        for digital in digitais_to_delete:
            command = f"DELETAR:{digital.sensor_id}\n"
            self.ser.write(command.encode('utf-8'))
            self.stdout.write(f"-> Comando enviado: DELETAR:{digital.sensor_id}")
            await asyncio.sleep(0.1)
            
        # A exclus√£o do banco ocorrer√° quando o hardware responder com DELETAR_OK.
        # Apenas enviamos um feedback de que os comandos foram enviados.
        message = f"Comandos para apagar as digitais de {user.nome_completo} foram enviados ao hardware."
        await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'success', 'message': message}})


    def handle(self, *args, **kwargs):
        self.stdout.write(self.style.SUCCESS('Iniciando gerenciador de hardware unificado...'))
        asyncio.run(self.main_loop())

    async def main_loop(self):
        await self.channel_layer.group_add('serial_worker_group', 'serial_worker_channel')
        is_connected = False

        await sync_to_async(cache.set)('hardware_reader_status', 'desconectado', timeout=None)

        while True:
            serial_port = find_serial_port_by_hwid()

            if serial_port:
                if not is_connected:
                    self.stdout.write(self.style.SUCCESS(f"Dispositivo encontrado na porta {serial_port}. Tentando conectar..."))
                    is_connected = True

                try:
                    self.ser = serial.Serial(serial_port, BAUD_RATE, timeout=0.1)
                    self.stdout.write(self.style.SUCCESS(f'Conectado com sucesso a {serial_port}'))
                    
                    # ---> ATUALIZA O CACHE
                    await sync_to_async(cache.set)('hardware_reader_status', 'conectado', timeout=None)

                    # Anuncia o status 'conectado' para todos os grupos
                    for group_name in ['login_group', 'dashboard_group']:
                        await self.channel_layer.group_send(group_name, {'type': 'broadcast_message', 'message': {'type': 'status.leitor', 'status': 'conectado'}})

                    # Loop principal de opera√ß√£o enquanto estiver conectado
                    while True:
                        if self.ser.in_waiting > 0:
                            line = self.ser.readline().decode('utf-8').strip()
                            if line:
                                self.stdout.write(f'<< DADO DO HARDWARE: {line}')
                                await process_serial_data(line, self.channel_layer, self)
                        
                        try:
                            message = await asyncio.wait_for(self.channel_layer.receive('serial_worker_channel'), timeout=0.01) #
                            if message['type'] == 'arm.action': #
                                await self.cancel_pending_action() #
                                self.pending_action = message['action'] #
                                self.stdout.write(self.style.WARNING(f"A√á√ÉO ARMADA: {self.pending_action} - Aguardando por {ACTION_TIMEOUT}s")) #
                                self.action_timer = asyncio.get_event_loop().call_later(ACTION_TIMEOUT, lambda: asyncio.create_task(self.cancel_pending_action())) #
                                await self.channel_layer.group_send('dashboard_group', {'type': 'broadcast_message', 'message': {'type': 'action.feedback', 'status': 'info', 'message': 'A√ß√£o iniciada! Aproxime a digital de um SUPERUSU√ÅRIO para confirmar.'}}) #
                            elif message['type'] == 'execute.command': #
                                command = message['command'] #
                                self.stdout.write(self.style.WARNING(f'>> COMANDO DO SITE: {command}')) #
                                self.ser.write(f'{command}\n'.encode('utf-8')) #
                        except asyncio.TimeoutError:
                            pass

                except serial.SerialException:
                    self.stdout.write(self.style.ERROR(f'A conex√£o com {serial_port} foi perdida. Procurando novamente...'))
                    if self.ser: self.ser.close()
                    self.ser = None
                    is_connected = False

                    # ---> ATUALIZA O CACHE
                    await sync_to_async(cache.set)('hardware_reader_status', 'desconectado', timeout=None)

                    # Anuncia o status 'desconectado'
                    for group_name in ['login_group', 'dashboard_group']:
                        await self.channel_layer.group_send(group_name, {'type': 'broadcast_message', 'message': {'type': 'status.leitor', 'status': 'desconectado'}})
                    await asyncio.sleep(2)
            
            else: # Se serial_port for None
                if is_connected:
                    self.stdout.write(self.style.ERROR('Dispositivo LancheGO desconectado. Procurando novamente...'))
                    is_connected = False

                    # ---> ATUALIZA O CACHE
                    await sync_to_async(cache.set)('hardware_reader_status', 'desconectado', timeout=None)

                    # Anuncia o status 'desconectado'
                    for group_name in ['login_group', 'dashboard_group']:
                        await self.channel_layer.group_send(group_name, {'type': 'broadcast_message', 'message': {'type': 'status.leitor', 'status': 'desconectado'}})
                
                # Se n√£o encontrar a porta, espera um pouco e tenta de novo
                await asyncio.sleep(2)

==================== FIM ARQUIVO: backend/api/management/commands/listen_serial.py ====================

==================== INICIO ARQUIVO: frontend/app/administrators/page.tsx ====================
// app/administrators/page.tsx (VERS√ÉO FINAL ATUALIZADA E ALINHADA)
"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Plus, Pencil, Trash2, Fingerprint, Loader2, Eye, EyeOff, LogOut,
  ShieldAlert, CheckCircle, XCircle, Usb, PlugZap, Search, AlertTriangle,
} from "lucide-react";
import apiClient from "@/lib/api";
import { useAuth } from "@/context/AuthContext";
import { useToast } from "@/components/ui/use-toast";

interface Server {
  id: number;
  nome_completo: string;
  user: {
    id: number;
    username: string;
    is_superuser: boolean; 
  };
  digitais_count: number;
}

// --- MUDAN√áA 1: TIPO DE ESTADO ALINHADO COM A P√ÅGINA DE ALUNOS ---
type EnrollmentStatusType = {
  message: string;
  state: "loading" | "success" | "error" | "idle";
};

export default function ServersManagementPage() {
  const [servers, setServers] = useState<Server[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingServer, setEditingServer] = useState<Server | null>(null);
  const [activeToastId, setActiveToastId] = useState<string | null>(null);
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [nomeCompleto, setNomeCompleto] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [passwordConfirm, setPasswordConfirm] = useState("");
  const [enrollmentStatus, setEnrollmentStatus] = useState<EnrollmentStatusType>({ message: "Aguardando in√≠cio...", state: "idle" });
  const [isEnrolling, setIsEnrolling] = useState(false);
  const [readerStatus, setReaderStatus] = useState<"connected" | "disconnected">("disconnected");
  const [searchTerm, setSearchTerm] = useState("");
  
  const ws = useRef<WebSocket | null>(null);
  const { token, logout, user: loggedInUser, isLoading: isLoadingAuth } = useAuth();
  const router = useRouter();
  const { toast, dismiss } = useToast();

  // --- CORRE√á√ÉO 1: Envelopando fetchServers com useCallback ---
  const fetchServers = useCallback(async () => {
    if (!token) return;
    setIsLoading(true);
    try {
      const response = await apiClient.get("/servidores/");
      setServers(response.data);
    } catch (error) {
      console.error("Falha ao buscar servidores:", error);
    } finally {
      setIsLoading(false);
    }
  }, [token]);


  // --- CORRE√á√ÉO 2: Ref para evitar que o useEffect dependa de 'editingServer' ---
  const editingServerRef = useRef(editingServer);
  useEffect(() => {
    editingServerRef.current = editingServer;
  }, [editingServer]);

  useEffect(() => {
    if (isLoadingAuth || !token) {
        if (!isLoadingAuth && !token) { router.push('/admin'); }
        return;
    }
    // Prote√ß√£o extra para garantir que apenas superusu√°rios acessem esta p√°gina
    if (loggedInUser && !loggedInUser.is_superuser) {
        router.push('/dashboard');
        return;
    }

    let isMounted = true;

    const connectWebSocket = () => {
      if (ws.current && ws.current.readyState === WebSocket.OPEN) return;
      if (!isMounted) return;

      const wsUrl = "ws://127.0.0.1:8000/ws/hardware/dashboard_group/";
      ws.current = new WebSocket(wsUrl);

      ws.current.onopen = () => { console.log("AdminPage: WebSocket Conectado!"); };
      ws.current.onclose = () => {
        if (!isMounted) return;
        setReaderStatus("disconnected");
        setTimeout(connectWebSocket, 3000);
      };
      ws.current.onerror = (error) => {
        console.error("AdminPage: Erro no WebSocket:", error);
        ws.current?.close();
      };

      ws.current.onmessage = (event) => {
        if (!isMounted) return;
        const data = JSON.parse(event.data);
        const activeServer = editingServerRef.current;
        
        if (activeToastId && (data.type === 'action.feedback' || data.type === 'delete.result' || data.type === 'clearall.result')) {
            dismiss(activeToastId);
            setActiveToastId(null);
        }

        switch (data.type) {
          case "cadastro.feedback":
            setEnrollmentStatus({ message: data.message, state: "loading" });
            break;
          case "cadastro.success":
            if (editingServer)
              handleAssociateFingerprint(data.sensor_id, editingServer.id);
            break;
          case "cadastro.error":
            setEnrollmentStatus({
              message: `Erro no leitor: ${data.message}`,
              state: "error",
            });
            setTimeout(() => {
              setIsEnrolling(false);
              setEnrollmentStatus({
                message: "Aguardando in√≠cio...",
                state: "idle",
              });
            }, 3000);
            break;
          case "status.leitor":
            setReaderStatus(
              data.status === "conectado" ? "connected" : "disconnected"
            );
            break;
          case "delete.result":
            if (data.status === "OK") {
              toast({
                title: "Sucesso!",
                description: `A digital (ID: ${data.sensor_id}) foi apagada com sucesso do hardware.`,
              });
              fetchServers();
            } else {
              toast({
                title: "Erro de Hardware",
                description: "O leitor reportou uma falha ao tentar apagar a digital.",
                variant: "destructive",
              });
            }
            break;
          case "action.feedback":
            toast({
              title:
                data.status === "success"
                  ? "Sucesso!"
                  : data.status === "error"
                  ? "Erro!"
                  : "Aviso",
              description: data.message,
              variant: data.status === "error" ? "destructive" : "default",
            });
            if (data.status === "success") {
              fetchServers();
            }
            break;
          case "clearall.result":
            toast({
              title:
                data.status === "OK"
                  ? "Opera√ß√£o Conclu√≠da"
                  : "Falha na Opera√ß√£o",
              description:
                data.status === "OK"
                  ? "Mem√≥ria do leitor limpa com sucesso!"
                  : "O hardware reportou um erro ao limpar a mem√≥ria.",
              variant: data.status === "OK" ? "default" : "destructive",
            });
            fetchServers();
            break;
        }
      };
    };

    connectWebSocket();
    fetchServers();

    return () => {
      isMounted = false;
      if (ws.current) {
        ws.current.onclose = null;
        ws.current.close();
      }
    };
  }, [token, isLoadingAuth, router, fetchServers, loggedInUser]);

  // --- MUDAN√áA 4: FUN√á√ÉO DE SALVAR COM VALIDA√á√ÉO E MELHOR TRATAMENTO DE ERRO ---
  const handleSaveServer = async () => {
    if (!editingServer && password !== passwordConfirm) {
      alert("As senhas n√£o coincidem.");
      return;
    }

    const serverData = {
      username: username,
      password: password,
      nome_completo: nomeCompleto,
    };
    const payload = Object.fromEntries(
      Object.entries(serverData).filter(([_, v]) => v !== null && v !== "")
    );

    try {
      if (editingServer) {
        await apiClient.patch(`/servidores/${editingServer.id}/`, payload);
      } else {
        await apiClient.post("/servidores/register/", payload);
      }
      fetchServers();
      setIsModalOpen(false);
      resetForm();
    } catch (error: any) {
      console.error("Falha ao salvar servidor:", error);
      if (error.response && error.response.data) {
        const errors = error.response.data;
        let errorMessages = Object.keys(errors).map(
          (key) => `${key}: ${errors[key].join(", ")}`
        );
        alert(`Falha ao salvar servidor:\n- ${errorMessages.join("\n- ")}`);
      } else {
        alert("Falha ao salvar servidor. Verifique os dados e a conex√£o.");
      }
    }
  };

  const handleInitiateDeleteServer = async (serverId: number) => {
      try {
          const response = await apiClient.post(`/actions/initiate-delete-server/${serverId}/`);
          toast({
              title: "A√ß√£o Iniciada",
              description: response.data.message,
          });
      } catch (error: any) {
          toast({
              title: "Erro",
              description: "N√£o foi poss√≠vel iniciar a a√ß√£o de exclus√£o.",
              variant: "destructive"
          });
      }
  };

  // --- Busca
  const filteredServers = servers.filter((server) =>
    server.nome_completo.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // --- MUDAN√áA 5: FUN√á√ïES DE GERENCIAMENTO DE DIGITAL ALINHADAS ---
  const handleStartEnrollment = async (server: Server | null) => {
    if (!server || readerStatus === "disconnected") return;
    setIsEnrolling(true);
    setEnrollmentStatus({
      message: "Conectando ao hardware...",
      state: "loading",
    });

    setTimeout(() => {
      if (ws.current && ws.current.readyState === WebSocket.OPEN) {
        ws.current.send(
          JSON.stringify({ type: "hardware.command", command: "CADASTRO" })
        );
        setEnrollmentStatus({
          message: "Comando enviado. Siga as instru√ß√µes no leitor.",
          state: "loading",
        });
      } else {
        setEnrollmentStatus({
          message: "Erro: Falha na conex√£o com o hardware.",
          state: "error",
        });
        setTimeout(() => setIsEnrolling(false), 3000);
      }
    }, 100);
  };

  const handleAssociateFingerprint = async (
    sensorId: number,
    serverId: number
  ) => {
    setEnrollmentStatus({
      message: "Digital lida! Associando ao servidor...",
      state: "loading",
    });
    try {
      await apiClient.post("/digitais/associar/", {
        sensor_id: sensorId,
        servidor_id: serverId,
      });
      setEnrollmentStatus({
        message: "Digital associada com sucesso!",
        state: "success",
      });
      await fetchServers();
      setEditingServer((prev) =>
        prev ? { ...prev, digitais_count: prev.digitais_count + 1 } : null
      );
      setTimeout(() => setIsEnrolling(false), 2500);
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.error || "Erro de comunica√ß√£o.";
      console.error(
        "Falha ao associar digital:",
        error.response?.data || error
      );
      setEnrollmentStatus({
        message: `Falha na associa√ß√£o: ${errorMessage}`,
        state: "error",
      });
      setTimeout(() => {
        setIsEnrolling(false);
        setEnrollmentStatus({ message: "Aguardando in√≠cio...", state: "idle" });
      }, 4000);
    }
  };

  const handleInitiateDeleteFingerprints = async (serverId: number) => {
      const { id, dismiss } = toast({ // <-- Capturamos o ID e a fun√ß√£o dismiss
        title: "A√ß√£o Iniciada",
        description: "Aguardando confirma√ß√£o biom√©trica no leitor...",
      });
      setActiveToastId(id); // Guardamos o ID do toast ativo

      try {
        await apiClient.post(
          `/actions/initiate-delete-server-fingerprints/${serverId}/`
        );
      } catch (error) {
        dismiss(); // Fecha o toast de "Aguardando" se a inicia√ß√£o falhar
        setActiveToastId(null);
        toast({
          title: "Erro",
          description: "N√£o foi poss√≠vel iniciar a exclus√£o de digitais.",
          variant: "destructive",
        });
      }
  };

  // --- MUDAN√áA: Fun√ß√£o de limpar leitor agora apenas INICIA a a√ß√£o ---
  const handleInitiateClearAll = async () => {
    try {
      const response = await apiClient.post("/actions/initiate-clear-all/");
      toast({
        title: "A√ß√£o Iniciada",
        description: response.data.message,
      });
    } catch (error) {
      console.error("Falha ao iniciar limpeza do leitor:", error);
      toast({
        title: "Erro",
        description: "N√£o foi poss√≠vel iniciar a a√ß√£o de limpeza.",
        variant: "destructive",
      });
    }
  };

  const openEditModal = (server: Server) => {
    setEditingServer(server);
    setNomeCompleto(server.nome_completo);
    setUsername(server.user.username);
    setPassword("");
    setIsModalOpen(true);
  };

  const resetForm = () => {
    setEditingServer(null);
    setUsername("");
    setPassword("");
    setNomeCompleto("");
    setPasswordConfirm("");
    setIsEnrolling(false);
    setEnrollmentStatus({ message: "Aguardando in√≠cio...", state: "idle" });
  };

  const handleLogout = () => {
    logout();
    router.push("/admin");
  };

  const EnrollmentStatusDisplay = () => {
    if (!isEnrolling) return null;
    const iconMap = {
      loading: <Loader2 className="h-5 w-5 animate-spin" />,
      success: <CheckCircle className="h-5 w-5 text-green-500" />,
      error: <XCircle className="h-5 w-5 text-red-500" />,
      idle: null,
    };
    return (
      <div className="flex items-center space-x-2 bg-muted p-3 rounded-lg w-full justify-center">
        {iconMap[enrollmentStatus.state]}
        <span className="text-sm font-medium text-muted-foreground text-center">
          {enrollmentStatus.message}
        </span>
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
      <div className="p-6">
        <header className="flex justify-between items-center mb-6">
          <div className="flex items-center space-x-4">
            <h1 className="text-2xl font-bold">Gest√£o de Servidores</h1>
            <div
              className={`flex items-center space-x-2 p-2 rounded-lg border text-sm font-medium ${
                readerStatus === "connected"
                  ? "bg-green-100 text-green-800 border-green-200"
                  : "bg-red-100 text-red-800 border-red-200"
              }`}
            >
              {readerStatus === "connected" ? (
                <Usb className="h-4 w-4" />
              ) : (
                <PlugZap className="h-4 w-4" />
              )}
              <span>
                {readerStatus === "connected"
                  ? "Leitor Conectado"
                  : "Leitor Desconectado"}
              </span>
            </div>
          </div>
          <div className="flex items-center space-x-4">
            <AlertDialog>
              <AlertDialogTrigger asChild>
                <Button variant="destructive">
                  <ShieldAlert className="mr-2 h-4 w-4" />
                  Limpar Leitor
                </Button>
              </AlertDialogTrigger>
              <AlertDialogContent>
                <AlertDialogHeader>
                  <AlertDialogTitle>
                    Aten√ß√£o! A√ß√£o Irrevers√≠vel!
                  </AlertDialogTitle>
                  <AlertDialogDescription>
                    Esta a√ß√£o ir√° apagar TODAS as digitais da mem√≥ria do leitor.
                    Para continuar, ser√° exigida a confirma√ß√£o com a digital de
                    um superusu√°rio.
                  </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                  <AlertDialogCancel>Cancelar</AlertDialogCancel>
                  {/* --- MUDAN√áA: onClick agora chama a fun√ß√£o de INICIA√á√ÉO --- */}
                  <AlertDialogAction
                    onClick={handleInitiateClearAll}
                    className="bg-destructive hover:bg-destructive/90"
                  >
                    Iniciar Limpeza
                  </AlertDialogAction>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialog>
            <Button
              onClick={() => {
                resetForm();
                setIsModalOpen(true);
              }}
            >
              <Plus className="mr-2 h-4 w-4" />
              Adicionar Novo Servidor
            </Button>
          </div>
        </header>

        <Card>
          <CardHeader>
            <div className="relative w-full max-w-sm">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" />
              <Input
                placeholder="Buscar servidor por nome..."
                className="pl-10"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
          </CardHeader>

          <CardContent className="p-4">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Nome</TableHead>
                  <TableHead>Usu√°rio de Login</TableHead>
                  <TableHead>Status Biom√©trico</TableHead>
                  <TableHead className="text-right">A√ß√µes</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={4} className="text-center">
                      Carregando...
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredServers.map((server) => (
                    <TableRow key={server.id}>
                      <TableCell className="flex items-center">
                        {server.nome_completo}
                        {/* --- MUDAN√áA 1: Adicionando a Badge de Superuser --- */}
                      </TableCell>
                      <TableCell>{server.user.username}
                        {server.user.is_superuser && (
                            <Badge
                                variant="destructive"
                                className="ml-2 bg-yellow-200 text-black hover:bg-yellow-200"
                            >
                                Superuser
                            </Badge>
                        )}
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center">
                          {server.digitais_count === 0 && (
                            <Badge variant="destructive">Inativo</Badge>
                          )}
                          {server.digitais_count === 1 && (
                            <>
                              <Badge className="bg-yellow-500 hover:bg-yellow-600">
                                Parcial
                              </Badge>
                              <AlertTriangle
                                className="ml-2 h-4 w-4 text-yellow-500"
                                aria-label="Apenas uma digital cadastrada"
                              />
                            </>
                          )}
                          {server.digitais_count >= 2 && (
                            <Badge className="bg-green-500 hover:bg-green-600">
                              Ativo
                            </Badge>
                          )}
                        </div>
                      </TableCell>
                      <TableCell className="text-right">
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => openEditModal(server)}
                        >
                          <Pencil className="h-4 w-4" />
                        </Button>

                        <AlertDialog>
                          <AlertDialogTrigger asChild>
                            <Button
                              size="sm"
                              variant="ghost"
                              className="text-red-500 hover:text-red-600 disabled:opacity-50 disabled:cursor-not-allowed"
                              disabled={server.user.is_superuser} // <-- Bot√£o desabilitado se for superuser
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </AlertDialogTrigger>
                          <AlertDialogContent>
                            <AlertDialogHeader>
                              <AlertDialogTitle>
                                Confirmar Exclus√£o
                              </AlertDialogTitle>
                              <AlertDialogDescription>
                                Tem certeza que deseja excluir o servidor "
                                {server.nome_completo}"?
                              </AlertDialogDescription>
                            </AlertDialogHeader>
                            <AlertDialogFooter>
                              <AlertDialogCancel>Cancelar</AlertDialogCancel>
                              <AlertDialogAction
                                  onClick={() => handleInitiateDeleteServer(server.id)} // <-- MUDAN√áA AQUI
                                  className="bg-destructive hover:bg-destructive/90"
                              >
                                  Excluir
                              </AlertDialogAction>
                            </AlertDialogFooter>
                          </AlertDialogContent>
                        </AlertDialog>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </CardContent>
        </Card>

        <Dialog
          open={isModalOpen}
          onOpenChange={(isOpen) => {
            if (!isOpen) resetForm();
            setIsModalOpen(isOpen);
          }}
        >
          <DialogContent>
            <DialogHeader>
              <DialogTitle>
                {editingServer ? "Editar Servidor" : "Adicionar Novo Servidor"}
              </DialogTitle>
            </DialogHeader>
            <div className="py-4 space-y-4">
              <div className="space-y-2">
                <Label htmlFor="name">Nome Completo</Label>
                <Input
                  id="name"
                  value={nomeCompleto}
                  onChange={(e) => setNomeCompleto(e.target.value)}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="username">Usu√°rio de Login</Label>
                <Input
                  id="username"
                  value={username}
                  onChange={(e) => setUsername(e.target.value)}
                  disabled={!!editingServer}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="password">
                  Senha {editingServer && "(Deixe em branco para n√£o alterar)"}
                </Label>
                <div className="relative">
                  <Input
                    id="password"
                    type={showPassword ? "text" : "password"}
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                  />
                  <Button
                    type="button"
                    variant="ghost"
                    size="sm"
                    className="absolute right-0 top-0 h-full px-3 py-2"
                    onClick={() => setShowPassword(!showPassword)}
                  >
                    {showPassword ? (
                      <EyeOff className="h-4 w-4" />
                    ) : (
                      <Eye className="h-4 w-4" />
                    )}
                  </Button>
                </div>
              </div>
              {!editingServer && (
                <div className="space-y-2">
                  <Label htmlFor="passwordConfirm">Confirme a Senha</Label>
                  <Input
                    id="passwordConfirm"
                    type={showPassword ? "text" : "password"}
                    value={passwordConfirm}
                    onChange={(e) => setPasswordConfirm(e.target.value)}
                  />
                </div>
              )}

              {editingServer && (
                <div className="space-y-4 pt-4 border-t">
                  <div className="flex justify-between items-center">
                    <h3 className="font-semibold">Gerenciamento de Digitais</h3>
                    {editingServer.digitais_count > 0 && (
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <Button variant="destructive" size="sm">
                            <Trash2 className="mr-2 h-4 w-4" />
                            Apagar Digitais
                          </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>
                              Confirmar Exclus√£o
                            </AlertDialogTitle>
                            <AlertDialogDescription>
                              Tem certeza que deseja apagar TODAS as digitais de{" "}
                              {editingServer.nome_completo}?
                            </AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>Cancelar</AlertDialogCancel>
                            <AlertDialogAction
                              onClick={() =>
                                handleInitiateDeleteFingerprints(
                                  editingServer.id
                                )
                              }
                              className="bg-destructive hover:bg-destructive/90"
                            >
                              Sim, Apagar Tudo
                            </AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                    )}
                  </div>

                  {editingServer.digitais_count < 2 ? (
                    !isEnrolling ? (
                      <Button
                        onClick={() => handleStartEnrollment(editingServer)}
                        variant="outline"
                        disabled={readerStatus === "disconnected"}
                      >
                        <Fingerprint className="mr-2 h-4 w-4" />
                        {`Cadastrar ${
                          editingServer.digitais_count === 0 ? "1¬™" : "2¬™"
                        } Digital`}
                      </Button>
                    ) : (
                      <EnrollmentStatusDisplay />
                    )
                  ) : (
                    <Badge variant="secondary">
                      Limite de 2 digitais atingido
                    </Badge>
                  )}
                </div>
              )}
            </div>
            <DialogFooter>
              <Button variant="outline" onClick={() => setIsModalOpen(false)}>
                Cancelar
              </Button>
              <Button onClick={handleSaveServer}>
                {editingServer ? "Salvar Altera√ß√µes" : "Adicionar Servidor"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>
    </div>
  );
}

==================== FIM ARQUIVO: frontend/app/administrators/page.tsx ====================

==================== INICIO ARQUIVO: frontend/app/students/page.tsx ====================
// app/students/page.tsx (VERS√ÉO FINAL CORRIGIDA E ROBUSTA)
"use client";

import { useState, useEffect, useRef, useCallback } from "react";
import { TURMA_NOMES } from "@/lib/utils"
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Plus,
  Pencil,
  Trash2,
  Fingerprint,
  Search,
  AlertTriangle,
  Loader2,
  Usb,
  PlugZap,
  CheckCircle,
  XCircle,
  ShieldAlert,
} from "lucide-react";
import apiClient from "@/lib/api";
import { useAuth } from "@/context/AuthContext";
import { useToast } from "@/components/ui/use-toast";

interface Student {
  id: number;
  nome_completo: string;
  matricula: string;
  turma: string;
  digitais_count: number;
}

// --- NOVO TIPO PARA STATUS DE CADASTRO ---
type EnrollmentStatusType = {
  message: string;
  state: "loading" | "success" | "error" | "idle";
};

export default function StudentsPage() {
  const [students, setStudents] = useState<Student[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [turmaFilter, setTurmaFilter] = useState("Todas as Turmas");
  const [readerStatus, setReaderStatus] = useState<"connected" | "disconnected">("disconnected");
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [addModalStep, setAddModalStep] = useState(1);
  const [newlyCreatedStudent, setNewlyCreatedStudent] = useState<Student | null>(null);
  const [newStudent, setNewStudent] = useState({ nome_completo: "", matricula: "", turma: "" });
  const [editingStudent, setEditingStudent] = useState<Student | null>(null);

  // --- MUDAN√áA 1: Melhorando o estado do "enrollmentStatus" para ser um objeto ---
  const [enrollmentStatus, setEnrollmentStatus] = useState<EnrollmentStatusType>({ message: "Aguardando in√≠cio...", state: "idle" });
  const [isEnrolling, setIsEnrolling] = useState(false);
  const [turmaToDelete, setTurmaToDelete] = useState<string>("");
  const ws = useRef<WebSocket | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  // --- Adicioando planilha e + filtros
  const [isUploadModalOpen, setIsUploadModalOpen] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [uploadStatus, setUploadStatus] = useState<string | null>(null);
  const [biometricFilter, setBiometricFilter] = useState("todos");
  const [uploadPhase, setUploadPhase] = useState<'idle' | 'uploading' | 'complete'>('idle');
  


const { token, isLoading: isLoadingAuth } = useAuth();
  const router = useRouter();
  const { toast } = useToast();


  const fetchStudents = async () => {
      // A verifica√ß√£o do token agora est√° no useEffect, esta fun√ß√£o se torna mais simples
      setIsLoading(true);
      try {
        const response = await apiClient.get("/alunos/");
        setStudents(response.data);
      } catch (error) {
        console.error("Falha ao buscar alunos:", error);
      } finally {
        setIsLoading(false);
      }
  };

  // --- Refs para evitar "stale state" no websocket, mantendo a conex√£o est√°vel ---
  const editingStudentRef = useRef(editingStudent);
  const newlyCreatedStudentRef = useRef(newlyCreatedStudent);
  useEffect(() => {
    editingStudentRef.current = editingStudent;
    newlyCreatedStudentRef.current = newlyCreatedStudent;
  }, [editingStudent, newlyCreatedStudent]);

  useEffect(() => {
    // 1. L√≥gica de Prote√ß√£o
    if (isLoadingAuth) { // Usando o isLoading do useAuth()
      return; // Espera a autentica√ß√£o terminar
    }
    if (!token) {
      router.push('/');
      return;
    }

    // 2. Com o token validado, busca os alunos
    fetchStudents();

    let isMounted = true;

    const connectWebSocket = () => {
      if (ws.current && ws.current.readyState === WebSocket.OPEN) return;
      if (!isMounted) return;

      const wsUrl = "ws://127.0.0.1:8000/ws/hardware/dashboard_group/";
      ws.current = new WebSocket(wsUrl);

      ws.current.onopen = () => {
        if (!isMounted) return;
        console.log("StudentsPage: WebSocket Conectado!");
      };

      ws.current.onclose = () => {
        if (!isMounted) return;
        console.log("StudentsPage: WebSocket Desconectado. Tentando reconectar em 3s...");
        setReaderStatus("disconnected");
        setTimeout(connectWebSocket, 3000); // Tenta reconectar
      };

      ws.current.onerror = (error) => {
        if (!isMounted) return;
        console.error("StudentsPage: Erro no WebSocket:", error);
        ws.current?.close(); // For√ßa o onclose para disparar a reconex√£o
      };

      ws.current.onmessage = (event) => {
        if (!isMounted) return;
        const data = JSON.parse(event.data);
        const activeStudent = editingStudentRef.current || newlyCreatedStudentRef.current;

        switch (data.type) {
            case "status.leitor":
                setReaderStatus(data.status === "conectado" ? "connected" : "disconnected");
                break;
            case "cadastro.success":
                if (activeStudent) {
                    handleAssociateFingerprint(data.sensor_id, activeStudent.id);
                }
                break;
            case "cadastro.error":
                setEnrollmentStatus({ message: `Erro no leitor: ${data.message}`, state: "error" });
                setTimeout(() => {
                    setIsEnrolling(false);
                    setEnrollmentStatus({ message: "Aguardando in√≠cio...", state: "idle" });
                }, 3000);
                break;
            case "delete.result":
                if (data.status === "OK") {
                    fetchStudents();
                }
                break;
            case "action.feedback":
                toast({
                    title: data.status === "success" ? "Sucesso!" : (data.status === "error" ? "Erro!" : "Aviso"),
                    description: data.message,
                    variant: data.status === "error" ? "destructive" : "default",
                });
                if (data.status === "success" || data.message.includes("removidos")) {
                    fetchStudents();
                }
                break;
        }
      };
    };

    connectWebSocket();

    return () => {
      isMounted = false;
      if (ws.current) {
        ws.current.onclose = null;
        ws.current.close();
      }
    };
  // A lista de depend√™ncias agora √© limpa e correta
  }, [token, isLoadingAuth, router]); 
  

  const handleAddNewStudentAndProceed = async () => {
    try {
      const response = await apiClient.post("/alunos/", newStudent);
      setNewlyCreatedStudent(response.data);
      fetchStudents();
      setAddModalStep(2);
    } catch (error) {
      console.error("Falha ao adicionar aluno:", error);
    }
  };

  const handleUpdateStudent = async () => {
    if (!editingStudent) return;
    try {
      await apiClient.put(`/alunos/${editingStudent.id}/`, {
        nome_completo: editingStudent.nome_completo,
        matricula: editingStudent.matricula,
        turma: editingStudent.turma,
      });
      fetchStudents();
      setIsEditModalOpen(false);
    } catch (error) {
      console.error("Falha ao atualizar aluno:", error);
    }
  };

  const handleDeleteStudent = async (studentId: number) => {
      try {
          // Agora chama a rota de INICIA√á√ÉO, em vez de deletar diretamente
          const response = await apiClient.post(`/actions/initiate-delete-student/${studentId}/`);
          toast({
              title: "A√ß√£o Iniciada",
              description: response.data.message,
          });
          // N√£o chamamos fetchStudents() aqui, pois a exclus√£o ainda n√£o ocorreu.
          // O WebSocket enviar√° a mensagem de sucesso que atualizar√° a lista.
      } catch (error: any) {
          toast({
              title: "Erro de Permiss√£o",
              description: error.response?.status === 403
                  ? "Apenas superusu√°rios podem apagar alunos."
                  : "N√£o foi poss√≠vel iniciar a a√ß√£o de exclus√£o.",
              variant: "destructive"
          });
      }
  };

  const handleInitiateDeleteFingerprints = async (studentId: number) => {
      if (!studentId) return;
      try {
          const response = await apiClient.post(`/actions/initiate-delete-student-fingerprints/${studentId}/`);
          toast({
              title: "A√ß√£o Iniciada",
              description: response.data.message,
          });
      } catch (error) {
          toast({ title: "Erro", description: "N√£o foi poss√≠vel iniciar a exclus√£o de digitais.", variant: "destructive" });
      }
  };

  // --- MUDAN√áA 3: Fun√ß√£o de associa√ß√£o de digital completamente refeita para ser mais robusta ---
  const handleAssociateFingerprint = async (sensorId: number, studentId: number) => {
    setEnrollmentStatus({ message: "Digital lida! Associando ao aluno...", state: "loading" });
    try {
      await apiClient.post("/digitais/associar/", {
        sensor_id: sensorId,
        aluno_id: studentId,
      });

      setEnrollmentStatus({ message: "Digital associada com sucesso!", state: "success" });
      await fetchStudents();

      // Atualiza o contador de digitais do aluno ativo na modal
      if(editingStudent) {
        setEditingStudent(prev => prev ? {...prev, digitais_count: prev.digitais_count + 1} : null);
      }
      if(newlyCreatedStudent) {
        setNewlyCreatedStudent(prev => prev ? {...prev, digitais_count: prev.digitais_count + 1} : null);
      }

      setTimeout(() => {
        setIsEnrolling(false);
        // N√£o fecha a modal de edi√ß√£o, apenas a de adi√ß√£o
        if (isAddModalOpen) {
          resetAddModal();
        }
      }, 2500);

    } catch (error: any) {
      const errorMessage = error.response?.data?.error || "Erro de comunica√ß√£o com o servidor.";
      console.error("Falha ao associar digital:", error.response?.data || error);
      setEnrollmentStatus({ message: `Falha na associa√ß√£o: ${errorMessage}`, state: "error" });

      // Permite que o usu√°rio tente novamente sem fechar a modal
      setTimeout(() => {
        setIsEnrolling(false);
        setEnrollmentStatus({ message: "Aguardando in√≠cio...", state: "idle" });
      }, 4000);
    }
  };

  const handleStartEnrollment = async (student: Student | null) => {
    if (!student || readerStatus === 'disconnected') {
      if(readerStatus === 'disconnected') {
        alert("N√£o √© poss√≠vel iniciar o cadastro. O leitor de digitais est√° desconectado.");
      }
      return;
    };

    setIsEnrolling(true);
    setEnrollmentStatus({ message: "Conectando ao hardware...", state: "loading" });

    setTimeout(() => {
      if (ws.current && ws.current.readyState === WebSocket.OPEN) {
        ws.current.send(
          JSON.stringify({
            type: "hardware.command",
            command: "CADASTRO",
          })
        );
        setEnrollmentStatus({ message: "Comando enviado. Siga as instru√ß√µes no leitor.", state: "loading" });
      } else {
        console.error("WebSocket n√£o est√° conectado. N√£o foi poss√≠vel enviar o comando.");
        setEnrollmentStatus({ message: "Erro: Falha na conex√£o com o hardware.", state: "error" });
        setTimeout(() => setIsEnrolling(false), 3000);
      }
    }, 500);
  };

  // --- NOVA FUNCIONALIDADE: Fun√ß√£o para iniciar a exclus√£o por turma ---
  const handleInitiateDeleteByTurma = async () => {
    if (!turmaToDelete) {
        toast({ title: "A√ß√£o cancelada", description: "Por favor, selecione uma turma.", variant: "destructive" });
        return;
    }
    try {
        const response = await apiClient.post('/actions/initiate-delete-by-turma/', { turma: turmaToDelete });
        toast({ title: "A√ß√£o Iniciada", description: response.data.message });
    } catch (error) {
        console.error("Falha ao iniciar exclus√£o por turma:", error);
        toast({ title: "Erro", description: "N√£o foi poss√≠vel iniciar a a√ß√£o de exclus√£o.", variant: "destructive" });
    }
  };

  const handleFileUpload = async () => {
    if (!selectedFile) {
        alert("Por favor, selecione um arquivo de planilha.");
        return;
    }
    setUploadPhase('uploading');
    setUploadStatus("Enviando e processando, por favor aguarde...");
    const formData = new FormData();
    formData.append('planilha', selectedFile);

    try {
        const response = await apiClient.post('/alunos/upload-planilha/', formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
        const { criados, existentes_ignorados, erros } = response.data;
        let summary = `Importa√ß√£o conclu√≠da!\n- Alunos novos criados: ${criados}\n- Alunos j√° existentes (ignorados): ${existentes_ignorados}`;
        if (erros.length > 0) {
            summary += `\n- Erros encontrados: ${erros.length}\n\nDetalhes dos erros:\n${erros.join('\n')}`;
        }
        setUploadStatus(summary);
        fetchStudents(); // Atualiza a lista
    } catch (error: any) {
      // --- MUDAN√áA AQUI: Verificando o c√≥digo de status do erro ---
      if (error.response && error.response.status === 403) {
          setUploadStatus("Acesso Negado: Apenas superusu√°rios podem importar planilhas.");
      } else {
          setUploadStatus(`Erro: ${error.response?.data?.error || "Falha na comunica√ß√£o com o servidor."}`);
      }
    } finally {
        setUploadPhase('complete'); // <-- MUDAN√áA: Define a fase como "conclu√≠do"
    }
  };

  const resetUploadModal = () => {
    setSelectedFile(null);
    setUploadStatus(null);
    setUploadPhase('idle');
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const filteredStudents = students.filter((student) => {
      const nameMatch = student.nome_completo.toLowerCase().includes(searchTerm.toLowerCase());
      const turmaMatch = turmaFilter === "Todas as Turmas" || student.turma === turmaFilter;

      const biometricMatch = 
          biometricFilter === "todos" ||
          (biometricFilter === "nao_cadastrados" && student.digitais_count === 0) ||
          (biometricFilter === "parcial" && student.digitais_count === 1);

      return nameMatch && turmaMatch && biometricMatch;
  });

  const resetAddModal = () => {
    setIsAddModalOpen(false);
    setTimeout(() => {
        setAddModalStep(1);
        setNewlyCreatedStudent(null);
        setNewStudent({ nome_completo: "", matricula: "", turma: "" });
        setIsEnrolling(false);
        setEnrollmentStatus({ message: "Aguardando in√≠cio...", state: "idle" });
    }, 300);
  }

  // --- MUDAN√áA 4: Componente para renderizar o status do cadastro de forma mais clara ---
  const EnrollmentStatusDisplay = () => {
    if (!isEnrolling) return null;

    const iconMap = {
      loading: <Loader2 className="h-5 w-5 animate-spin" />,
      success: <CheckCircle className="h-5 w-5 text-green-500" />,
      error: <XCircle className="h-5 w-5 text-red-500" />,
      idle: null,
    };

    return (
      <div className="flex items-center space-x-2 bg-muted p-3 rounded-lg w-full justify-center">
        {iconMap[enrollmentStatus.state]}
        <span className="text-sm font-medium text-muted-foreground text-center">{enrollmentStatus.message}</span>
      </div>
    );
  };

  return (
    <div className="flex h-screen bg-gray-100 dark:bg-gray-900">
      <div className="flex-1 p-6">
        <div className="flex justify-between items-center mb-6">
          <div className="flex items-center space-x-4">
            <h1 className="text-2xl font-bold">Gest√£o de Alunos</h1>
            <div
              className={`flex items-center space-x-2 p-2 rounded-lg border text-sm font-medium ${
                readerStatus === "connected"
                  ? "bg-green-100 text-green-800 border-green-200 dark:bg-green-900/30 dark:text-green-300 dark:border-green-700/50"
                  : "bg-red-100 text-red-800 border-red-200 dark:bg-red-900/30 dark:text-red-300 dark:border-red-700/50"
              }`}
            >
              {readerStatus === "connected" ? <Usb className="h-4 w-4" /> : <PlugZap className="h-4 w-4" />}
              <span>{readerStatus === "connected" ? "Leitor Conectado" : "Leitor Desconectado"}</span>
            </div>
          </div>
          <div className="flex items-center space-x-2">
              {/* --- NOVA FUNCIONALIDADE: Bot√£o para A√ß√µes em Massa --- */}
              <AlertDialog>
                  <AlertDialogTrigger asChild>
                      <Button variant="destructive"><ShieldAlert className="mr-2 h-4 w-4" /> A√ß√µes em Massa</Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                      <AlertDialogHeader>
                          <AlertDialogTitle>Exclus√£o de Alunos por Turma</AlertDialogTitle>
                          <AlertDialogDescription>
                              Esta a√ß√£o ir√° apagar TODOS os alunos e suas respectivas digitais da turma selecionada. Esta opera√ß√£o √© destinada para o fim do ano letivo e n√£o pode ser desfeita.
                              <br/><br/>
                              **Selecione apenas turmas de 3¬∫ ano para evitar exclus√µes acidentais.**
                          </AlertDialogDescription>
                      </AlertDialogHeader>
                      <div className="py-4">
                          <Label htmlFor="turma-delete">Selecione a Turma para Excluir</Label>
                          <Select onValueChange={setTurmaToDelete}>
                              <SelectTrigger><SelectValue placeholder="Selecione uma turma..." /></SelectTrigger>
                              <SelectContent>
                                  <SelectItem value="3E">3¬∫ Ano Eletro</SelectItem>
                                  <SelectItem value="3I">3¬∫ Ano Info</SelectItem>
                              </SelectContent>
                          </Select>
                      </div>
                      <AlertDialogFooter>
                          <AlertDialogCancel onClick={() => setTurmaToDelete("")}>Cancelar</AlertDialogCancel>
                          <AlertDialogAction onClick={handleInitiateDeleteByTurma} className="bg-destructive hover:bg-destructive/90">Iniciar Exclus√£o</AlertDialogAction>
                      </AlertDialogFooter>
                  </AlertDialogContent>
              </AlertDialog>

              <Button onClick={() => setIsAddModalOpen(true)}>
                  <Plus className="mr-2 h-4 w-4" /> Adicionar Novo Aluno
              </Button>
          </div>
        </div>
        

        <Card>
          <CardHeader>
            <div className="flex items-center space-x-4">
              <div className="relative w-full max-w-sm">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-5 w-5 text-gray-400" />
                <Input
                  placeholder="Buscar aluno por nome..."
                  className="pl-10"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
              <Select onValueChange={setTurmaFilter} defaultValue="Todas as Turmas">
                <SelectTrigger className="w-[200px]">
                  <SelectValue placeholder="Filtrar por turma" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Todas as Turmas">Todas as Turmas</SelectItem>
                  <SelectItem value="1E">1¬∫ Ano Eletro</SelectItem>
                  <SelectItem value="2E">2¬∫ Ano Eletro</SelectItem>
                  <SelectItem value="3E">3¬∫ Ano Eletro</SelectItem>
                  <SelectItem value="1I">1¬∫ Ano Info</SelectItem>
                  <SelectItem value="2I">2¬∫ Ano Info</SelectItem>
                  <SelectItem value="3I">3¬∫ Ano Info</SelectItem>
                </SelectContent>
              </Select>
              <div className="flex items-center space-x-2">
                  <Select onValueChange={setBiometricFilter} defaultValue="todos">
                      <SelectTrigger className="w-[220px]">
                          <SelectValue placeholder="Filtrar por status biom√©trico" />
                      </SelectTrigger>
                      <SelectContent>
                          <SelectItem value="todos">Todos os Status</SelectItem>
                          <SelectItem value="nao_cadastrados">N√£o Cadastrados (0)</SelectItem>
                          <SelectItem value="parcial">Parcial (1)</SelectItem>
                      </SelectContent>
                  </Select>

                  <Button variant="outline" onClick={() => setIsUploadModalOpen(true)}>
                      <Plus className="mr-2 h-4 w-4" /> Importar Planilha
                  </Button>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Nome Completo</TableHead>
                  <TableHead>Matr√≠cula</TableHead>
                  <TableHead>Turma</TableHead>
                  <TableHead>Status Biom√©trico</TableHead>
                  <TableHead className="text-right">A√ß√µes</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {isLoading ? (
                  <TableRow>
                    <TableCell colSpan={5} className="text-center">Carregando alunos...</TableCell>
                  </TableRow>
                ) : (
                  filteredStudents.map((student) => (
                    <TableRow key={student.id}>
                      <TableCell className="font-medium ">{student.nome_completo}</TableCell>
                      <TableCell>{student.matricula}</TableCell>
                      <TableCell>{TURMA_NOMES[student.turma] || student.turma}</TableCell>
                      <TableCell>
                        <div className="flex items-center">
                          {student.digitais_count === 0 && <Badge variant="destructive">Inativo</Badge>}
                          {student.digitais_count === 1 && (
                            <>
                              <Badge className="bg-yellow-500 hover:bg-yellow-600">Parcial</Badge>
                              <AlertTriangle
                                className="ml-2 h-4 w-4 text-yellow-500"
                                aria-label="Apenas uma digital cadastrada"
                              />
                            </>
                          )}
                          {student.digitais_count >= 2 && <Badge className="bg-green-500 hover:bg-green-600">Ativo</Badge>}
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex justify-end items-center space-x-2">
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => {
                              setEditingStudent(student);
                              setIsEditModalOpen(true);
                            }}
                          >
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <AlertDialog>
                            <AlertDialogTrigger asChild>
                              <Button variant="ghost" size="icon" className="text-red-500 hover:text-red-600">
                                <Trash2 className="h-4 w-4" />
                              </Button>
                            </AlertDialogTrigger>
                            <AlertDialogContent>
                              <AlertDialogHeader>
                                <AlertDialogTitle>Confirmar Exclus√£o</AlertDialogTitle>
                                <AlertDialogDescription>
                                  Tem certeza que deseja excluir o aluno "{student.nome_completo}"?
                                  Esta a√ß√£o n√£o pode ser desfeita.
                                </AlertDialogDescription>
                              </AlertDialogHeader>
                              <AlertDialogFooter>
                                <AlertDialogCancel>Cancelar</AlertDialogCancel>
                                <AlertDialogAction
                                  onClick={() => handleDeleteStudent(student.id)}
                                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                                >
                                  Excluir
                                </AlertDialogAction>
                              </AlertDialogFooter>
                            </AlertDialogContent>
                          </AlertDialog>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
      </div>

      {/* --- MODAL ADI√á√ÉO EM ETAPAS --- */}
      <Dialog open={isAddModalOpen} onOpenChange={(isOpen) => { if (!isOpen) resetAddModal() }}>
        <DialogContent>
          {addModalStep === 1 && (
            <>
              <DialogHeader>
                <DialogTitle>Adicionar Novo Aluno - Etapa 1 de 2</DialogTitle>
              </DialogHeader>
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <Label htmlFor="add-name">Nome Completo</Label>
                  <Input id="add-name" value={newStudent.nome_completo} onChange={(e) => setNewStudent({ ...newStudent, nome_completo: e.target.value })} />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="add-matricula">Matr√≠cula</Label>
                  <Input id="add-matricula" value={newStudent.matricula} onChange={(e) => setNewStudent({ ...newStudent, matricula: e.target.value })} />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="add-turma">Turma</Label>
                  <Select onValueChange={(value) => setNewStudent({ ...newStudent, turma: value })}>
                    <SelectTrigger><SelectValue placeholder="Selecione a turma" /></SelectTrigger>
                    <SelectContent>
                      <SelectItem value="1E">1¬∫ Ano Eletro</SelectItem>
                      <SelectItem value="2E">2¬∫ Ano Eletro</SelectItem>
                      <SelectItem value="3E">3¬∫ Ano Eletro</SelectItem>
                      <SelectItem value="1I">1¬∫ Ano Info</SelectItem>
                      <SelectItem value="2I">2¬∫ Ano Info</SelectItem>
                      <SelectItem value="3I">3¬∫ Ano Info</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={resetAddModal}>Cancelar</Button>
                <Button onClick={handleAddNewStudentAndProceed}>Continuar para Digital</Button>
              </DialogFooter>
            </>
          )}

          {addModalStep === 2 && newlyCreatedStudent && (
            <>
              <DialogHeader>
                <DialogTitle>Digital para: {newlyCreatedStudent.nome_completo}</DialogTitle>
              </DialogHeader>
              <div className="space-y-4 pt-4 flex flex-col items-center justify-center min-h-[150px]">
                {!isEnrolling ? (
                  <Button onClick={() => handleStartEnrollment(newlyCreatedStudent)} variant="outline" size="lg" disabled={readerStatus === 'disconnected'}>
                    <Fingerprint className="mr-2 h-5 w-5" />
                    Cadastrar Digital
                  </Button>
                ) : (
                  <EnrollmentStatusDisplay />
                )}
              </div>
              <DialogFooter>
                <Button onClick={resetAddModal}>Concluir</Button>
              </DialogFooter>
            </>
          )}
        </DialogContent>
      </Dialog>
      
      {/* --- MODAL EDI√á√ÉO --- */}
      <Dialog open={isEditModalOpen} onOpenChange={setIsEditModalOpen}>
        <DialogContent className="sm:max-w-[600px]">
          <DialogHeader>
            <DialogTitle>Editar Aluno</DialogTitle>
          </DialogHeader>
          {editingStudent && (
            <>
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <Label htmlFor="edit-name">Nome Completo</Label>
                  <Input
                    id="edit-name"
                    value={editingStudent.nome_completo}
                    onChange={(e) => setEditingStudent({ ...editingStudent, nome_completo: e.target.value })}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="edit-matricula">Matr√≠cula</Label>
                  <Input
                    id="edit-matricula"
                    value={editingStudent.matricula}
                    onChange={(e) => setEditingStudent({ ...editingStudent, matricula: e.target.value })}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="edit-turma">Turma</Label>
                  <Select
                    value={editingStudent.turma}
                    onValueChange={(value) => setEditingStudent({ ...editingStudent, turma: value })}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Selecione a turma" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="1E">1¬∫ Ano Eletro</SelectItem>
                      <SelectItem value="2E">2¬∫ Ano Eletro</SelectItem>
                      <SelectItem value="3E">3¬∫ Ano Eletro</SelectItem>
                      <SelectItem value="1I">1¬∫ Ano Info</SelectItem>
                      <SelectItem value="2I">2¬∫ Ano Info</SelectItem>
                      <SelectItem value="3I">3¬∫ Ano Info</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-4 pt-4 border-t">
                  <div className="flex justify-between items-center">
                    <h3 className="font-semibold">Gerenciamento de Digitais</h3>
                    {editingStudent.digitais_count > 0 && (
                      <AlertDialog>
                        <AlertDialogTrigger asChild>
                          <Button variant="destructive" size="sm">
                            <Trash2 className="mr-2 h-4 w-4" />
                            Apagar Digitais
                          </Button>
                        </AlertDialogTrigger>
                        <AlertDialogContent>
                          <AlertDialogHeader>
                            <AlertDialogTitle>Confirmar Exclus√£o</AlertDialogTitle>
                            <AlertDialogDescription>
                              Tem certeza que deseja apagar TODAS as digitais de {editingStudent.nome_completo}?
                              O aluno precisar√° ser cadastrado novamente.
                            </AlertDialogDescription>
                          </AlertDialogHeader>
                          <AlertDialogFooter>
                            <AlertDialogCancel>Cancelar</AlertDialogCancel>
                            <AlertDialogAction
                              onClick={() => handleInitiateDeleteFingerprints(editingStudent.id)}
                              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                            >
                              Sim, Apagar Tudo
                            </AlertDialogAction>
                          </AlertDialogFooter>
                        </AlertDialogContent>
                      </AlertDialog>
                    )}
                  </div>

                  {editingStudent.digitais_count < 2 ? (
                    !isEnrolling ? (
                      <Button onClick={() => handleStartEnrollment(editingStudent)} variant="outline" disabled={readerStatus === 'disconnected'}>
                        <Fingerprint className="mr-2 h-4 w-4" />
                        {`Cadastrar ${editingStudent.digitais_count === 0 ? "1¬™" : "2¬™"} Digital`}
                      </Button>
                    ) : (
                      <EnrollmentStatusDisplay />
                    )
                  ) : (
                    <Badge variant="secondary">Limite de 2 digitais atingido</Badge>
                  )}
                </div>
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setIsEditModalOpen(false)}>Cancelar</Button>
                <Button onClick={handleUpdateStudent}>Salvar Altera√ß√µes</Button>
              </DialogFooter>
            </>
          )}
        </DialogContent>
      </Dialog>
      
      <Dialog open={isUploadModalOpen} onOpenChange={(isOpen) => { if (!isOpen) { setSelectedFile(null); setUploadStatus(null); } setIsUploadModalOpen(isOpen); }}>
          <DialogContent>
              <DialogHeader>
                  <DialogTitle>Importar Alunos via Planilha</DialogTitle>
              </DialogHeader>
              <div className="py-4 space-y-4">
                  {uploadPhase !== 'complete' && (
                      <>
                          <p className="text-sm text-muted-foreground">
                              Selecione uma planilha (.xlsx) com as colunas: NOME e TURMA (codinome).
                          </p>
                          <Input
                              id="file-upload" // Adicionado um ID
                              ref={fileInputRef} // --- MUDAN√áA 4: Associando a refer√™ncia ao input ---
                              type="file"
                              accept=".xlsx"
                              onChange={(e) => setSelectedFile(e.target.files ? e.target.files[0] : null)}
                          />
                      </>
                  )}
                  {uploadStatus && (
                      <div className="mt-4 max-h-40 overflow-y-auto rounded-md border bg-muted p-3 text-sm">
                          <pre className="whitespace-pre-wrap font-sans">
                              {uploadStatus}
                          </pre>
                      </div>
                  )}
              </div>
              <DialogFooter>
                  {uploadPhase === 'complete' ? (
                      <>
                          <Button variant="outline" onClick={() => setIsUploadModalOpen(false)}>Fechar</Button>
                          <Button onClick={resetUploadModal}>
                              <Plus className="mr-2 h-4 w-4" /> Importar Outra
                          </Button>
                      </>
                  ) : (
                      <>
                          <Button variant="outline" onClick={() => setIsUploadModalOpen(false)}>Cancelar</Button>
                          <Button onClick={handleFileUpload} disabled={!selectedFile || uploadPhase === 'uploading'}>
                              {uploadPhase === 'uploading' && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                              {uploadPhase === 'uploading' ? 'Enviando...' : 'Enviar Planilha'}
                          </Button>
                      </>
                  )}
              </DialogFooter>
          </DialogContent>
      </Dialog>
    </div>
  );
}
==================== FIM ARQUIVO: frontend/app/students/page.tsx ====================

==================== INICIO ARQUIVO: frontend/context/AuthContext.tsx ====================
// context/AuthContext.tsx (Vers√£o Final Corrigida com Tipagem)
"use client";

import { createContext, useState, useContext, useEffect, ReactNode, useCallback  } from 'react';
import apiClient from '@/lib/api';
import { useRouter } from 'next/navigation';
import { jwtDecode } from 'jwt-decode';

// Interface para os dados do usu√°rio que extra√≠mos do token
interface User {
  user_id: number;
  username: string;
  is_superuser: boolean;
}

// Definimos a "forma" do nosso contexto para o TypeScript
interface AuthContextType {
    token: string | null;
    user: User | null; // <-- MUDAN√áA: Tipagem corrigida de 'any' para 'User | null'
    login: (newToken: string) => User | null;
    logout: () => void;
    isLoading: boolean;
}

// Criamos o contexto com um valor inicial nulo, mas com o tipo definido
const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
    const [user, setUser] = useState<User | null>(null);
    const [token, setToken] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const router = useRouter();

    const updateUserFromToken = useCallback((currentToken: string | null) => {
        if (currentToken) {
            // Define o token no estado e nos headers do apiClient
            setToken(currentToken);
            apiClient.defaults.headers['Authorization'] = `Bearer ${currentToken}`;
            
            // Decodifica o token para extrair as informa√ß√µes do usu√°rio
            try {
                const decodedToken: any = jwtDecode(currentToken);
                setUser({
                    user_id: decodedToken.user_id,
                    username: decodedToken.username,
                    is_superuser: decodedToken.is_superuser || false
                });
            } catch (error) {
                console.error("Token inv√°lido:", error);
                // Se o token for inv√°lido, limpa tudo
                localStorage.removeItem('authToken');
                setToken(null);
                setUser(null);
            }
        } else {
            // Limpa o estado se n√£o houver token
            // Garante que o token seja removido do armazenamento permanente
            localStorage.removeItem('authToken');
            setToken(null);
            setUser(null);
            delete apiClient.defaults.headers['Authorization'];
        }
        // --- MUDAN√áA CR√çTICA: Avisa a aplica√ß√£o que o carregamento inicial terminou ---
        setIsLoading(false);
    }, []);

    useEffect(() => {
        const storedToken = localStorage.getItem('authToken');
        updateUserFromToken(storedToken);
    }, [updateUserFromToken]);
    
    // --- MUDAN√áA AQUI ---
    const login = (newToken: string): User | null => {
        localStorage.setItem('authToken', newToken);
        // A fun√ß√£o updateUserFromToken j√° atualiza o estado interno.
        // Aqui, n√≥s decodificamos novamente apenas para retornar o valor imediatamente.
        try {
            const decodedToken: any = jwtDecode(newToken);
            const loggedInUser = {
                user_id: decodedToken.user_id,
                username: decodedToken.username,
                is_superuser: decodedToken.is_superuser || false
            };
            updateUserFromToken(newToken); // Continua atualizando o contexto
            return loggedInUser;
        } catch (e) {
            updateUserFromToken(null);
            return null;
        }
    };

    const logout = () => {
        updateUserFromToken(null);
        router.push('/');
    };

    return (
        <AuthContext.Provider value={{ token, user, login, logout, isLoading }}>
            {children}
        </AuthContext.Provider>
    );
};

// Hook customizado para usar o contexto
export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === null) {
        throw new Error("useAuth deve ser usado dentro de um AuthProvider");
    }
    return context;
};
==================== FIM ARQUIVO: frontend/context/AuthContext.tsx ====================

==================== INICIO ARQUIVO: frontend/components/navigation.tsx ====================
"use client"

import Link from "next/link"
import { usePathname, useRouter } from "next/navigation"
import { useAuth } from "@/context/AuthContext";
import { cn } from "@/lib/utils"
import { Home, Users, LogOut, Settings } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge";

const getNavigationItems = (pathname: string) => {
  // Admin pages should only show relevant admin links
  if (pathname.startsWith("/admin")) {
    return [{ name: "Gest√£o de Servidores", href: "/administrators", icon: Settings }]
  }

  // Regular user navigation (removed "Gest√£o de Administradores")
  return [
    { name: "Painel Principal", href: "/dashboard", icon: Home },
    { name: "Gest√£o de Alunos", href: "/students", icon: Users },
  ]
}

export function Navigation() {
  const pathname = usePathname();
  // --- MUDAN√áA: Importando o AuthContext e o Router ---
  const { user, logout } = useAuth();
  const router = useRouter();

  console.log("Dados do Usu√°rio na Navega√ß√£o:", user);

  if (pathname === "/" || pathname === "/admin") return null;

  // --- MUDAN√áA: L√≥gica de navega√ß√£o agora √© baseada nas permiss√µes do usu√°rio ---
  const navigation = [
    { name: "Painel Principal", href: "/dashboard", icon: Home },
    { name: "Gest√£o de Alunos", href: "/students", icon: Users },
  ];

  if (user?.is_superuser) {
    navigation.push({ name: "Gest√£o de Servidores", href: "/administrators", icon: Settings });
  }

  const handleLogout = () => {
    logout();
    // Se estiver na p√°gina de admin, redireciona para o login de admin. Sen√£o, para o login principal.
    if (pathname.startsWith("/administrators")) {
      router.push('/admin');
    } else {
      router.push('/');
    }
  };

  return (
    <nav className="bg-card border-b border-border">
      <div className="max-w-7xl mx-auto px-6">
        <div className="flex justify-between items-center h-16">
          <div className="flex items-center space-x-8">
            <Link href="/dashboard" className="text-xl font-bold text-primary">
              LancheGO
            </Link>
            <div className="flex space-x-4">
              {navigation.map((item) => {
                const Icon = item.icon;
                return (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={cn(
                      "flex items-center space-x-2 px-3 py-2 rounded-md text-sm font-medium transition-colors",
                      pathname === item.href
                        ? "bg-primary text-primary-foreground"
                        : "text-muted-foreground hover:text-foreground hover:bg-muted"
                    )}
                  >
                    <Icon className="h-4 w-4" />
                    <span>{item.name}</span>
                  </Link>
                );
              })}
            </div>
          </div>
          {/* --- NOVO: Destaque para Superuser --- */}
          {user?.is_superuser && (
            <Badge variant="destructive" className="bg-yellow-500 text-black hover:bg-yellow-500">Superuser</Badge>
          )}
          {/* --- MUDAN√áA: O bot√£o "Sair" agora chama a fun√ß√£o handleLogout --- */}
          <Button variant="outline" size="sm" onClick={handleLogout} className="hover:bg-red-500/80 hover:text-white">
            <LogOut className="h-4 w-4 mr-2" />
            Sair
          </Button>
        </div>
      </div>
    </nav>
  );
}
==================== FIM ARQUIVO: frontend/components/navigation.tsx ====================

==================== INICIO ARQUIVO: backend/lanchego_project/settings.py ====================
"""
Django settings for lanchego_project project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-v$*a*7n5eo36-)peoj55r1#a-2yc^c(14_%ne__pwh07)z6svd'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'channels',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'corsheaders',
    'api',
    'rest_framework',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'lanchego_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'lanchego_project.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
ASGI_APPLICATION = 'lanchego_project.asgi.application'
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
    "http://lanchego:3000",
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    )
}

CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "channels_redis.core.RedisChannelLayer",
        "CONFIG": {
            "hosts": [("redis", 6379)],
        },
    },
}

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://redis:6379/1",  # <-- MUDAN√áA AQUI
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
    }
}

==================== FIM ARQUIVO: backend/lanchego_project/settings.py ====================

